<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"core-skeleton.js.html":{"id":"core-skeleton.js.html","title":"Source: core-skeleton.js","body":" Core Classes core Source: core-skeleton.js function typeOf(thing){ var type = Object.prototype.toString.call(thing); return type.substring(8, type.length -1).toLowerCase(); } /** * @name core * @constructor * @param {object} options - instance options. * @param {string} options.name - a unique name for the instance. * @param {array} options.plugins - an array on plugins to initialize on the instance. * @param {object} options.extend - if provided, this object will be merged in to the new instance. * @example * var core = new Core({ * name: 'client-core', * plugins: [ * require('./pluginA'), * require('./pluginB') * ] * }); */ function Core(options) { var core = this; if(!options) options = {}; core.name = options.name || 'core'; core.definitions = {}; core.plugins = {}; core.constructor = Core; core.core = core; if(options.plugins){ options.plugins.map(plugin =&gt; core.plugin(plugin)); } if(options.extend){ core.extend(options.extend); } } Core.prototype = { /** * @name core.typeOf * @function * @description Returns the correct native type in javascript ( unlike the 'typeof' operator ). * @param {any} thing - anything you want. * @return {string} The native javascript type - 'undefined', 'null', 'boolean', 'number', 'string', 'array', 'object' or 'function'. * @example * * typeof null; // 'object' * typeof []; // 'object' * * core.typeOf(null); // 'null' * core.typeOf([]); // 'array' * * */ typeOf: typeOf, /** * @function * @description Checks if a value is undefined. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is undefined. false otherwise. * @example * core.isUndefined(null); // false * */ isUndefined(v){ return typeOf(v) === 'undefined'; }, /** * @function * @description Checks if a value is null. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is null. false otherwise. * @example * core.isNull(null); // true * */ isNull(v){ return typeOf(v) === 'null'; }, /** * @function * @description Checks if a value is a boolean. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is boolean. false otherwise. * @example * core.isBoolean(false); // true * core.isBoolean(''); // false * */ isBoolean(v){ return typeOf(v) === 'boolean'; }, /** * @function * @description Checks if a value is a number. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is a number. false otherwise. * @example * core.isNumber('35'); // false * core.isNumber(35); // true * */ isNumber(v){ return typeOf(v) === 'number'; }, /** * @function * @description Checks if a value is a string. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is a string. false otherwise. * @example * core.isString('35'); // true * core.isString(35); // false * */ isString(v){ return typeOf(v) === 'string'; }, /** * @function * @description Checks if a value is a date object. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is an array. false otherwise. * @example * core.isDate('6/3/81'); // false * core.isDate(new Date('6/3/81')); // true * */ isDate(v){ return typeOf(v) === 'date'; }, /** * @function * @description Checks if a value is an array. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is an array. false otherwise. * @example * core.isArray({}); // false * core.isArray([]); // true * */ isArray(v){ return typeOf(v) === 'array'; }, /** * @function * @description Checks if a value is an object. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is an object. false otherwise. * @example * core.isObject({}); // true * core.isObject([]); // false * */ isObject(v){ return typeOf(v) === 'object'; }, /** * @function * @description Checks if a value is a function. * @param {any} thing - anything you want. * @return {boolean} - true if 'thing' is a function. false otherwise. * @example * core.isFunction({}); // false * core.isFunction(e =&gt; {}); // true * */ isFunction(v){ return typeOf(v) === 'function'; }, /** * @function * @description Copies all properties from 'source' to 'target', similar to Object.assign. * @param {object} target - The target object. properties will be copied to this object. * @param {object} source - A source, or a number of source objects. * @param {function} assignFunc - A function that will be called for each property assignment. * if provided, the assigned value will be the return value of this function. * @return {object} - The target object ( the first parameter ). * @example * core.assign({}, {a: 1, b: 2}, t =&gt; t + 1); // { a: 2, b: 3 } * */ assign(target, source, assignFunc) { var core = this; var desc, property, func, args = [].slice.call(arguments, 1); if (!core.isObject(target)) { throw new Error(`core.assign() - first argument should be an object. got ${ this.typeOf(target) }`); } if (core.isFunction(args[args.length - 1])) { func = args.pop(); } args.map(function(source){ if(!core.isObject(source)) return; for(var key in source){ desc = Object.getOwnPropertyDescriptor(source, key); if (desc &amp;&amp; desc.enumerable) { property = source[key] target[key] = func ? func(property, key, source) : property; } } }); return target; }, /** * @function * @description Copies all members in 'properties' to the core instance. * @param {object} properties - An * @return {object} - Returns the target object ( the first parameter ). * @example * core.extend({ * getData(){ return this.myData; }, * myData: 45 * }); * * core.getData(); // 45. * core.myData; // 45. * */ extend(properties){ var core = this; core.assign(core, properties, function(property){ if(core.isFunction(property)){ return property.bind(core); } return property; }); }, /** * A namespace object to hold named channels. */ channels: { 'core.pluginDefinition': [], 'core.plugin': [] }, /** * @function * @description Adds a new channel to the channels namespace object. * @param {string} name - The name of the channel. * @param {array} array - Optional array of functions. * @return {undefined} * @example * core.channel('collection'); * core.channels.collection; // []. * */ channel(name, array){ if(!name) throw new Error('core.channel() was called without a name'); if(!this.isString(name)) throw new Error(`core.channel() - expected first argument to be a string. got ${ this.typeOf(name) }`); if(this.isFunction(array)){ array = [array]; } else if(!this.isArray(array)){ array = []; } this.channels[name] = array; }, /** * @function * @description Adds a tap to a channel. * @param {string} name - The name of the channel. * @param {function} func - A function to attach to the channel. * @return {undefined} * @prop asd.asd.asd * @example * core.channel('dataType'); * * core.tap('dataType', (dataType, done) =&gt; { * dataType.test = 'ok'; * done(dataType); * }); * * core.fire('dataType', {}, (dataType) =&gt; { * dataType.test; // 'ok' * }); * */ tap(name, func){ if(!name) throw new Error('core.tap() was called without a name'); if(!this.isString(name)){ throw new Error(`core.tap() - expected first argument to be a string. got ${ this.typeOf(name) }`); } if(!this.isFunction(func)){ throw new Error(`core.tap() - expected second argument to be a function. got ${ this.typeOf(func) }`); } if(!this.isArray(this.channels[name])){ throw new Error(`core.tap() - cannot find channel ${ name }`); } this.channels[name].push(func); }, /** * @function * @description Runs data through a named channel. * @param {string} name - The name of the channel. * @param {any} data - Data to be passed through the channel. * @param {function} callback - A function that will be called when the job completes. * @return {undefined} * @example * core.channel('dataType', (dataType, done) =&gt; { * dataType.test = 'ok'; * done(dataType); * }); * * core.fire('dataType', {}, (dataType) =&gt; { * dataType.test; // 'ok' * }); * */ fire(name, data, callback){ var core = this; var index = 0; var returned = false; var channel = core.channels[name]; var args = [].slice.call(arguments, 1); callback = args.pop(); if(!channel) { throw new Error(`cannot find channel '${name}'`); } if(!core.isFunction(callback)){ args.push(callback); callback = null; } function done(){ index++; if(returned){ throw new Error(`'${ name }' channel has returned twice`); } returned = true; if(callback) { callback.apply(null, args); } } function next(){ if(index &gt;= channel.length) { return done(); } var tool = channel[index]; index++; var t = index; setTimeout(function(){ if(t !== index){ return } var ns = tool._ns ? tool._ns : (tool.name ? `function ${ tool.name } in channel ${ name }` : `function at index ${ t - 1 } in channel ${ name }`); console.warn(`${ ns } did not call next().`, args); }, 3000); tool.apply(core, args.concat([next, done])) } next.apply(null, args); }, /** * @function * @description Adds a plugin to core instance. * @param {object} definition - The plugin definition. * @param {string} definition.name - The name of the plugin. * @param {function} callback - A function that will be called when the job completes. * @return {undefined} * @example * core.plugin('myPlugin', { * getData(){ return 47; } * }); * core.plugins.myPlugin.getData(); // 47. * */ plugin(definition, callback) { var i, core = this; if (!definition) { throw new Error(`cannot create plugin from &quot;${definition}&quot;`); } if(core.isArray(definition)){ i = 0; function done(){ i += 1; if(1 &gt;= definition.length){ callback &amp;&amp; callback() } } return definition.map(function(def){ core.plugin(def, done); }); } if(!core.isObject(definition)){ throw new Error(`cannot create plugin from &quot;${definition}&quot;`); } if (!definition.name) { throw new Error(`a plugin's name is missing in Object ${ Object.keys(definition) }`); } core.definitions[definition.name] = definition; core.fire('core.pluginDefinition', definition, () =&gt; { var isDone = false; function done(plugin){ isDone = true; core.fire('core.plugin', plugin, definition, (plugin)=&gt;{ core.plugins[definition.name] = plugin || '√'; callback &amp;&amp; callback(plugin); }); } setTimeout(function(){ if(!isDone){ console.warn(`plugin ${ definition.name } has defined an init function but did not call done().`); } }, 3000); if(core.isFunction(definition.init)){ definition.init.call(core, definition, done); } else{ done(definition); } }); } } module.exports = Core; × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Apr 3rd 2017 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Core Classes core Classes Classes core × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Apr 3rd 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Core Classes core client-coreA modular client side toolchain. Documentation and terminology is not complete here, use at your own risk. Installationnpm install client-coreUsagevar core = require('client-core');PluginsYou can load a plugin by calling the core.plugin() method. it expects an object with at least a name property: // a very simple plugin is just an object with a name. core.plugin({ name: 'dataParser', parse(data){ ... } }); core.plugins.dataParser.parse({});The object that you provide to core.plugin() is called a pluginDefinition and it must contain a name ( which should be unique ). pluginDefinition.initIf you provide a function named init on your pluginDefinition, it will be called when the plugin is loading, and will be passed the pluginDefinition object and a done function. The done function should be called when you have finished preparing your plugin. whatever you pass to it will become the plugin's body. core.plugin({ name: 'test', init(pluginDefinition, done){ done(42); } }); core.plugins.test; // 42pluginDefinition.extendIf your pluginDefinition contains an object called extend, the extend object will be merged directly to the core object itself. if extend contains functions they will be bound to core. core.plugin({ name: 'extendTest', extend: { // this object will be merged into core. value: 42, getThis(){ return this; } } }); core.value; // 42 var { getThis } = core; getThis() === core; // true because getThis() has been bound to core.pluginDefinition.channelsIf your pluginDefinition contains an array called channels, a named channel will be created for each name in the array. ( see more about channels and hooks below. ) core.plugin({ name: 'channelsTest', channels: ['channelA', 'channelB'] // just an array of names. }); core.channels.channelA; // [] core.channels.channelB; // []Channels are just arrays of functions. When you fire up a channel, your data is being passed through the array of functions in async series. pluginDefinition.hooksIf your pluginDefinition contains an array called hooks, a hook will be tapped into every corresponding channel.the hooks array is expected to contain objects with a channel and a hook property: core.plugin({ name: 'hooksTest', hooks: [{ channel: 'channelA', // the name of the channel to hook to. hook(data, next, done){ // a hook function to run when the channel fires. data.hook = 'a'; next(); }, }, { channel: 'channelB', hook(data, next, done){ data.hook = 'b'; next(); } }] }); core.fire('channelA', {}, function(data){ data.hook; // 'a' }); core.fire('channelB', { value: 5 }, function(data){ data.value; // 5 data.hook; // 'b' });pluginDefinition. × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Apr 3rd 2017 using the DocStrap template. "},"core.html":{"id":"core.html","title":"Class: core","body":" Core Classes core Class: core core new core(options) Parameters: Name Type Description options object instance options. Properties Name Type Description name string a unique name for the instance. plugins array an array on plugins to initialize on the instance. extend object if provided, this object will be merged in to the new instance. Source: core-skeleton.js, line 8 Example var core = new Core({ name: 'client-core', plugins: [ require('./pluginA'), require('./pluginB') ] }); Methods &lt;static&gt; typeOf(thing) Returns the correct native type in javascript ( unlike the 'typeof' operator ). Parameters: Name Type Description thing any anything you want. Source: core-skeleton.js, line 43 Returns: The native javascript type - 'undefined', 'null', 'boolean', 'number', 'string', 'array', 'object' or 'function'. Type string Example typeof null; // 'object' typeof []; // 'object' core.typeOf(null); // 'null' core.typeOf([]); // 'array' × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Apr 3rd 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
